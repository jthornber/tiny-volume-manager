#!/usr/bin/env ruby

require 'trollop'

require 'lib/log'
require 'lib/tvm/tvm_api'

include Log
include TVM

#----------------------------------------------------------------

def puts_volume(volume, indent = 0)
  time = volume.create_time.to_s.chomp
  puts "#{" " * indent}#{volume.volume_id} #{time} #{volume.name}"
end

# Pick out the option that's been given, from a set of mutually
# exclusive options.
def msg_list_options(opts)
  # FIXME: use a fold, and write an rspec test
  msg = ""

  opts.each do |o|
    msg += "\n    #{o}"
  end

  msg
end

def get_exclusive_opt(opts, *flags)
  fset = flags.to_set
  oset = opts.select {|key, value| value}.keys.to_set

  intersection = fset & oset

  if intersection.size > 1
    msg = "These options are mutually exclusive:" + msg_list_options(intersection)
    raise ArgumentError, msg
  end

  if intersection.size == 0
    msg = "One of these options expected:" + msg_list_options(flags)
    raise ArgumentError, msg
  end

  intersection.to_a[0]
end

class VolumeSize
end

#----------------------------------------------------------------

open_log("./tvm.log")

SUB_COMMANDS = %w(create snap list commit abort status resize)

global_opts = Trollop::options do
  banner "tiny volume manager"
  stop_on SUB_COMMANDS
end

cmd = ARGV.shift
cmd_opts = case cmd
  when "create"
    Trollop::options do
    end

  when "snap"
    Trollop::options do
    end

  when "list"
    Trollop::options do
    end

  when "begin"
    Trollop::options do
    end

  when "abort"
    Trollop::options do
    end

  when "commit"
    Trollop::options do
    end

  when "resize"
    Trollop::options do
      opt :to, "Resize volume to the given size"
      opt :grow_to, "Grow volume to the given size"
      opt :shrink_to, "Shrink volume to the given size"
      opt :grow_by, "Grow volume by given amount"
      opt :shrink_by, "Shrink volume by given amount"
    end

  when "status"
    Trollop::options do
    end

  else
    Trollop::die "unknown subcommand #{cmd.inspect}"
end

#puts "Global options: #{global_opts.inspect}"
#puts "Subcommand: #{cmd.inspect}"
#puts "Subcommand options: #{cmd_opts.inspect}"
#puts "Remaining arguments: #{ARGV.inspect}"

#----------------------------------------------------------------

METADATA_FILE='./volumes.yaml'

metadata = YAMLMetadata.new(METADATA_FILE)
vm = VolumeManager.new(metadata)

# We're alway in an implicit transaction
vm.begin unless metadata.in_transaction?

case cmd
when 'commit'
  info "calling commit"
  vm.commit

when 'abort'
  vm.abort

when 'status'
  status = vm.status

  puts "# created volumes:"
  puts "#"
  status.created.each do |vol|
    puts "#    #{vol.name_or_short_id}"
  end
  puts "#" if status.created.size > 0
  
  puts "# modified volumes:"
  puts "#"
  status.modified.each do |vol|
    puts "#    #{vol.name_or_short_id}"
  end
  puts "#" if status.modified.size > 0

  puts "# deleted volumes:"
  puts "#"
  status.deleted.each do |vol|
    puts "#    #{vol.name_or_short_id}"
  end

when 'create'
  raise RuntimeError, "incorrect number of arguments" if ARGV.size != 1
  new_volume = vm.create_volume(name: ARGV[0])
  puts new_volume.volume_id

when 'list'
  show_children = true

  if ARGV.size == 1
    vols = [vm.volume_by_name(ARGV[0])]
    show_children = false
  else
    vols = vm.root_volumes
  end

  vols.each do |volume|
    puts_volume(volume)

    if show_children
      vm.child_volumes(volume.name).each do |child|
        puts_volume(child, 2)
      end
    end
  end

when 'resize'
  raise ArgumentError, "please specify the volume to be resized" unless ARGV.size > 0
  STDERR.puts cmd_opts
  get_exclusive_opt(cmd_opts,
                    :to,  :grow_to, :shrink_to, :grow_by, :shrink_by)

when 'snap'
  vm.snap_volume ARGV[0]
end

metadata.persist

#----------------------------------------------------------------

exit 0

